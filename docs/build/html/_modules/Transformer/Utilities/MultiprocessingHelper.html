<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Transformer.Utilities.MultiprocessingHelper &mdash; Transformer 0.0.1.dev37 documentation</title><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> Transformer
          </a>
              <div class="version">
                0.0.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">Transformer</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Transformer</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>Transformer.Utilities.MultiprocessingHelper</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for Transformer.Utilities.MultiprocessingHelper</h1><div class="highlight"><pre>
<span></span><span class="c1"># Transformer/Utilities/MultiprocessingHelper.py</span>


<span class="c1"># ----------------</span>
<span class="c1"># Module Docstring</span>
<span class="c1"># ----------------</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. module:: MultiprocessingHelper</span>
<span class="sd">    :synopsis: Contains primitives and routines for process-based parallelisation using the data-parallel model.</span>
<span class="sd">    :platform: Unix, Windows</span>

<span class="sd">.. moduleauthor:: Jonathan M. Skelton</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># -------</span>
<span class="c1"># Imports</span>
<span class="c1"># -------</span>

<span class="kn">import</span> <span class="nn">multiprocessing</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">time</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">warnings</span><span class="p">;</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c1"># Python 2.x.</span>

    <span class="kn">from</span> <span class="nn">Queue</span> <span class="kn">import</span> <span class="n">Empty</span><span class="p">,</span> <span class="n">Full</span><span class="p">;</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># Python &gt;= 3.</span>

    <span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">Empty</span><span class="p">,</span> <span class="n">Full</span><span class="p">;</span>

<span class="c1"># Try to import the tqdm module.</span>

<span class="n">_TQDM</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">tqdm</span><span class="p">;</span>

    <span class="n">_TQDM</span> <span class="o">=</span> <span class="kc">True</span><span class="p">;</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span><span class="p">;</span>


<span class="c1"># ---------</span>
<span class="c1"># Constants</span>
<span class="c1"># ---------</span>

<span class="sd">&quot;&quot;&quot; Delay for polling-based inter-process communication. &quot;&quot;&quot;</span>

<span class="n">PollDelay</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">;</span>

<span class="sd">&quot;&quot;&quot; Per-process number of items used to define the batch size for queue-based inter-process communication. &quot;&quot;&quot;</span>

<span class="n">QueueBatchItemsPerProcess</span> <span class="o">=</span> <span class="mi">250</span><span class="p">;</span>


<span class="c1"># ----------------</span>
<span class="c1"># Helper Functions</span>
<span class="c1"># ----------------</span>

<div class="viewcode-block" id="CPUCount"><a class="viewcode-back" href="../../../Transformer.Utilities.MultiprocessingHelper.html#Transformer.Utilities.MultiprocessingHelper.CPUCount">[docs]</a><span class="k">def</span> <span class="nf">CPUCount</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the number of CPU cores on the system.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        If :func:`multiprocessing.cpu_count()` raises a `NotImplementedError` (unlikely), this wrapper issues a warning and returns a &quot;safe&quot; value of 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    [type]</span>
<span class="sd">        [description]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cpuCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1"># According to the documentation, cpu_count() may raise a NotImplementedError; if this happens, issue a warning.</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">cpuCount</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">();</span>
    <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;multiprocessing.cpu_count() is not implemented on this platform -&gt; the CPU count will default to 1.&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">cpuCount</span><span class="p">;</span></div>


<span class="c1"># -------</span>
<span class="c1"># Classes</span>
<span class="c1"># -------</span>

<div class="viewcode-block" id="Counter"><a class="viewcode-back" href="../../../Transformer.Utilities.MultiprocessingHelper.html#Transformer.Utilities.MultiprocessingHelper.Counter">[docs]</a><span class="k">class</span> <span class="nc">Counter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements a simple shared-memory integer counter.</span>
<span class="sd">    Increments and decrements are protected by a lock, and reads can optionally also be protected.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initialValue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">readLock</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class constructor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        initialValue : int, optional</span>
<span class="sd">            initial count, by default 0.</span>
<span class="sd">        readLock : bool, optional</span>
<span class="sd">            process-safe reads, by default True.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">initialValue</span><span class="p">);</span>

<div class="viewcode-block" id="Counter.Current"><a class="viewcode-back" href="../../../Transformer.Utilities.MultiprocessingHelper.html#Transformer.Utilities.MultiprocessingHelper.Counter.Current">[docs]</a>    <span class="k">def</span> <span class="nf">Current</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the current value of the counter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        [type]</span>
<span class="sd">            [description]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="o">.</span><span class="n">get_lock</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="o">.</span><span class="n">value</span><span class="p">;</span></div>

<div class="viewcode-block" id="Counter.Decrement"><a class="viewcode-back" href="../../../Transformer.Utilities.MultiprocessingHelper.html#Transformer.Utilities.MultiprocessingHelper.Counter.Decrement">[docs]</a>    <span class="k">def</span> <span class="nf">Decrement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decrement the counter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        amount : int, optional</span>
<span class="sd">            amount to subtract from the counter, by default 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="o">.</span><span class="n">get_lock</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="o">.</span><span class="n">value</span> <span class="o">-=</span> <span class="n">amount</span><span class="p">;</span></div>

<div class="viewcode-block" id="Counter.Increment"><a class="viewcode-back" href="../../../Transformer.Utilities.MultiprocessingHelper.html#Transformer.Utilities.MultiprocessingHelper.Counter.Increment">[docs]</a>    <span class="k">def</span> <span class="nf">Increment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Increment the counter.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        amount : int, optional</span>
<span class="sd">            amount to add to the counter, by default 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="o">.</span><span class="n">get_lock</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="o">.</span><span class="n">value</span> <span class="o">+=</span> <span class="n">amount</span><span class="p">;</span></div></div>

<div class="viewcode-block" id="MapperBase"><a class="viewcode-back" href="../../../Transformer.Utilities.MultiprocessingHelper.html#Transformer.Utilities.MultiprocessingHelper.MapperBase">[docs]</a><span class="k">class</span> <span class="nc">MapperBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Base for Mapper classes to be passed to the :func:`~MultiprocessingHelper.QueueMap` routine. &quot;&quot;&quot;</span>

<div class="viewcode-block" id="MapperBase.Map"><a class="viewcode-back" href="../../../Transformer.Utilities.MultiprocessingHelper.html#Transformer.Utilities.MultiprocessingHelper.MapperBase.Map">[docs]</a>    <span class="k">def</span> <span class="nf">Map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map item and return output.</span>
<span class="sd">        This method must be overridden by derived classes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        item : [type]</span>
<span class="sd">            [description]</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            `Map()` must be overridden in a derived class.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Error: Map() must be overridden in a derived class.&quot;</span><span class="p">);</span></div></div>

<div class="viewcode-block" id="FunctionMapper"><a class="viewcode-back" href="../../../Transformer.Utilities.MultiprocessingHelper.html#Transformer.Utilities.MultiprocessingHelper.FunctionMapper">[docs]</a><span class="k">class</span> <span class="nc">FunctionMapper</span><span class="p">(</span><span class="n">MapperBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Basic Mapper which wrapps a supplied mapping function. &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapFunction</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Class constructor.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapFunction : [type]</span>
<span class="sd">            function for mapping input to output items.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">mapFunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Error: mapFunction cannot be None.&quot;</span><span class="p">;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_mapFunction</span> <span class="o">=</span> <span class="n">mapFunction</span><span class="p">;</span>

<div class="viewcode-block" id="FunctionMapper.Map"><a class="viewcode-back" href="../../../Transformer.Utilities.MultiprocessingHelper.html#Transformer.Utilities.MultiprocessingHelper.FunctionMapper.Map">[docs]</a>    <span class="k">def</span> <span class="nf">Map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map item to output using the function supplied to the constructor.</span>

<span class="sd">        .. note::</span>
<span class="sd">            - If item is a single value, it is passed to the mapping function using map_function(item); if item is a tuple, it is passed with map_function(*item).</span>
<span class="sd">            - For functions requiring a single tuple, wrap it in an outer tuple with e.g. ((arg1, arg2), ).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        item : [type]</span>
<span class="sd">            [description]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        [type]</span>
<span class="sd">            [description]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="c1"># If item is a tuple, unpack it using the *args syntax.</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapFunction</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">);</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mapFunction</span><span class="p">(</span><span class="n">item</span><span class="p">);</span></div></div>

<div class="viewcode-block" id="AccumulatorBase"><a class="viewcode-back" href="../../../Transformer.Utilities.MultiprocessingHelper.html#Transformer.Utilities.MultiprocessingHelper.AccumulatorBase">[docs]</a><span class="k">class</span> <span class="nc">AccumulatorBase</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Base for Accumulators to be passed to the :func:`~MultiprocessingHelper.QueueAccumulate` routine. &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AccumulatorBase.Accumulate"><a class="viewcode-back" href="../../../Transformer.Utilities.MultiprocessingHelper.html#Transformer.Utilities.MultiprocessingHelper.AccumulatorBase.Accumulate">[docs]</a>    <span class="k">def</span> <span class="nf">Accumulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process/accumulate a new item.</span>
<span class="sd">        This method must be overridden in derived classes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        item : [type]</span>
<span class="sd">            [description]</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            `Accumulate()` must be overridden by derived classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Error: Accumulate() must be overridden by derived classes.&quot;</span><span class="p">);</span></div>

<div class="viewcode-block" id="AccumulatorBase.Finalise"><a class="viewcode-back" href="../../../Transformer.Utilities.MultiprocessingHelper.html#Transformer.Utilities.MultiprocessingHelper.AccumulatorBase.Finalise">[docs]</a>    <span class="k">def</span> <span class="nf">Finalise</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finalise processing and return accumulated output.</span>
<span class="sd">        This method must be overridden in derived classes.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            `Finalise()` must be overridden by derived classes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Error: Finalise() must be overridden by derived classes.&quot;</span><span class="p">);</span></div></div>


<span class="c1"># ------------------</span>
<span class="c1"># QueueMap* Routines</span>
<span class="c1"># ------------------</span>

<div class="viewcode-block" id="QueueMap"><a class="viewcode-back" href="../../../Transformer.Utilities.MultiprocessingHelper.html#Transformer.Utilities.MultiprocessingHelper.QueueMap">[docs]</a><span class="k">def</span> <span class="nf">QueueMap</span><span class="p">(</span><span class="n">inputList</span><span class="p">,</span> <span class="n">mappers</span><span class="p">,</span> <span class="n">progressBar</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Map items in inputList to an in-order list of outputs, dividing the work among the supplied set of Mapper objects.</span>
<span class="sd">    Each Mapper is passed to a worker process, and the input list is processed in parallel using a queue-based producer-consumer model.</span>

<span class="sd">    .. note::</span>
<span class="sd">        - There is no guarentee which `Mapper` will process which input item(s), so all Mappers must return the same result for a given input.</span>
<span class="sd">        - The reason for using `Mapper` objects rather than a single mapping function is so each `Mapper` can e.g. use different working directories.</span>
<span class="sd">        - If the flexibilty of Mappers is not needed, the :func:`~MultiprocessingHelper.QueueMapFunction` routine presents a similar interface to the :func:`~multiprocessing.Pool.map` function.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        - If only one mapper is supplied, the input list will be mapped in serial.</span>
<span class="sd">        - If the :mod:`tqdm` module is not available, setting `progressBar = True` will issue a warning and a progress bar will not be displayed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inputList : list</span>
<span class="sd">        list of inputs to process with the Mappers.</span>
<span class="sd">    mappers : [type]</span>
<span class="sd">        a set of user-defined Mapper objects; the number of Mappers sets the number of worker processes that will be spawned.</span>
<span class="sd">    progressBar : bool, optional</span>
<span class="sd">        if True, and if the tqdm module is available, display a progress bar during mapping, by default False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    [type]</span>
<span class="sd">        [description]</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">        [description]</span>
<span class="sd">    Exception</span>
<span class="sd">        [description]</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">if</span> <span class="n">inputList</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Error: inputList cannot be None.&quot;</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">mappers</span> <span class="o">==</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">mappers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Error: At least one mapper must be supplied.&quot;</span><span class="p">);</span>

    <span class="n">numInputItems</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputList</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">numInputItems</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Don&#39;t do any work if we don&#39;t have to (!).</span>

        <span class="k">return</span> <span class="p">[];</span>

    <span class="c1"># If progressBar is set but the tqdm module is not available, issue a warning and reset it.</span>

    <span class="k">if</span> <span class="n">progressBar</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_TQDM</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The tqdm module could not be imported -&gt; progressBar will be reset to False.&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">);</span>

        <span class="n">progressBar</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>

    <span class="c1"># Create output list.</span>

    <span class="n">outputList</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numInputItems</span><span class="p">)];</span>

    <span class="c1"># Set up a primary iterator.</span>
    <span class="c1"># If the tqdm module is available, wrap the iterator to display a progress bar.</span>

    <span class="n">iValues</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numInputItems</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">progressBar</span><span class="p">:</span>
        <span class="n">iValues</span> <span class="o">=</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="n">iValues</span><span class="p">);</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mappers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># If there&#39;s only one mapper, there&#39;s no point in passing all the inputs and outputs through shared-memory queues.</span>

        <span class="n">mapper</span> <span class="o">=</span> <span class="n">mappers</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iValues</span><span class="p">:</span>
            <span class="n">outputList</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">Map</span><span class="p">(</span><span class="n">inputList</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Queue for passing input items to worker processes.</span>

        <span class="n">inputQueue</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Queue</span><span class="p">();</span>

        <span class="c1"># Queue for receiving input items from worker processes.</span>

        <span class="n">outputQueue</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Queue</span><span class="p">();</span>

        <span class="c1"># Flag to signal worker processes to terminate.</span>

        <span class="n">terminateFlag</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="c1"># Initialise worker processes.</span>

        <span class="n">workerProcesses</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span> <span class="o">=</span> <span class="n">_QueueMap_ProcessMain</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">inputQueue</span><span class="p">,</span> <span class="n">outputQueue</span><span class="p">,</span> <span class="n">terminateFlag</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">mapper</span> <span class="ow">in</span> <span class="n">mappers</span>
            <span class="p">];</span>

        <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">workerProcesses</span><span class="p">:</span>
            <span class="n">process</span><span class="o">.</span><span class="n">start</span><span class="p">();</span>

        <span class="c1"># Send input items to the worker threads and receive outputs.</span>

        <span class="c1"># The multiprocessing.Queue() has a fixed maximum size (at least on some platforms), so we need to put/get input/output items in batches.</span>
        <span class="c1"># If we don&#39;t, with large numbers of input items, the progress bar (if using) will not appear until the workers have processed enough items to allow the whole input list to be queued.</span>
        <span class="c1"># Worse still, if the output queue fills up before this can be done, we may end up with the equivalent of a deadlock.</span>

        <span class="c1"># Define the batch size as a fixed multiple of the number of worker processes.</span>

        <span class="n">batchSize</span> <span class="o">=</span> <span class="n">QueueBatchItemsPerProcess</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">workerProcesses</span><span class="p">);</span>

        <span class="c1"># Keep track of the next item to queue.</span>

        <span class="n">inputListPointer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1"># Submit an initial batch of work items.</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">batchSize</span><span class="p">,</span> <span class="n">numInputItems</span><span class="p">)):</span>
            <span class="c1"># Just in case batchSize &lt; numInputItems happens to exceed the maximum queue size.</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">inputQueue</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">inputListPointer</span><span class="p">,</span> <span class="n">inputList</span><span class="p">[</span><span class="n">inputListPointer</span><span class="p">])</span>
                    <span class="p">);</span>

                <span class="n">inputListPointer</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">except</span> <span class="n">Full</span><span class="p">:</span>
                <span class="k">break</span><span class="p">;</span>

        <span class="c1"># Go into a queue/dequeue loop until all the outputs have been retrieved.</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iValues</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">batchSize</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="n">inputListPointer</span><span class="p">:</span>
                <span class="c1"># Queue more input items if required.</span>

                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">batchSize</span><span class="p">,</span> <span class="n">numInputItems</span> <span class="o">-</span> <span class="n">inputListPointer</span><span class="p">)):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">inputQueue</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">inputListPointer</span><span class="p">,</span> <span class="n">inputList</span><span class="p">[</span><span class="n">inputListPointer</span><span class="p">])</span>
                            <span class="p">);</span>

                        <span class="n">inputListPointer</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="k">except</span> <span class="n">Full</span><span class="p">:</span>
                        <span class="k">break</span><span class="p">;</span>

            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># Try to fetch an output item and update the output list.</span>
                <span class="c1"># If none are available, sleep for a delay and try again.</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">index</span><span class="p">,</span> <span class="n">item</span> <span class="o">=</span> <span class="n">outputQueue</span><span class="o">.</span><span class="n">get_nowait</span><span class="p">();</span>
                    <span class="n">outputList</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>

                    <span class="k">break</span><span class="p">;</span>
                <span class="k">except</span> <span class="n">Empty</span><span class="p">:</span>
                    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">PollDelay</span><span class="p">);</span>

        <span class="c1"># Set the terminate flag and wait for the worker processes to pick it up and terminate.</span>

        <span class="n">terminateFlag</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">workerProcesses</span><span class="p">:</span>
            <span class="n">process</span><span class="o">.</span><span class="n">join</span><span class="p">();</span>

    <span class="c1"># Padding after progress bar.</span>

    <span class="k">if</span> <span class="n">progressBar</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span>

    <span class="c1"># Finally, return the output list.</span>

    <span class="k">return</span> <span class="n">outputList</span><span class="p">;</span></div>

<div class="viewcode-block" id="QueueMapFunction"><a class="viewcode-back" href="../../../Transformer.Utilities.MultiprocessingHelper.html#Transformer.Utilities.MultiprocessingHelper.QueueMapFunction">[docs]</a><span class="k">def</span> <span class="nf">QueueMapFunction</span><span class="p">(</span><span class="n">mapFunction</span><span class="p">,</span> <span class="n">inputList</span><span class="p">,</span> <span class="n">maxNumProcesses</span> <span class="o">=</span> <span class="n">CPUCount</span><span class="p">(),</span> <span class="n">progressBar</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Map items in inputList through mapFunction and return a list of outputs.</span>
<span class="sd">    This routine effectively implements a queue-based alternative to :func:`~multiprocessing.Pool.map` with support for a TQDM progress bar.</span>

<span class="sd">    .. note:: </span>
<span class="sd">        - Internally, `mapFunction` is wrapped by :class:`~MultiprocessingHelper.FunctionMapper` classes; therefore, pasing input items to the function works as per the :func:`~MultiprocessingHelper.FunctionMapper.Map` function of `FunctionMapper`.</span>
<span class="sd">        - If an item is a single value, it is passed to the mapping function with `map_function(item)`; if it is a tuple, it is passed as `map_function(*item)`.</span>
<span class="sd">        - Single-tuple arguments will need to be wrapped in an outer tuple, e.g. `((arg1, arg2), )`.</span>
<span class="sd">        - As for :func:`QueueMap()`, if `maxNumProcesses` is set to 1, a serial mapping will be performed without spawning any worker processes.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        - Similarly, if the :mod:`tqdm` module is not available, setting `progressBar = True` will not work and will cause a warning to be issued.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mapFunction : [type]</span>
<span class="sd">        [description]</span>
<span class="sd">    inputList : [type]</span>
<span class="sd">        [description]</span>
<span class="sd">    maxNumProcesses : [type], optional</span>
<span class="sd">        maximum number of worker processes, by default MultiprocessingHelper.CPUCount().</span>
<span class="sd">    progressBar : bool, optional</span>
<span class="sd">        if True, and if the tqdm module is available, display a progress bar during mapping, by default True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    [type]</span>
<span class="sd">        [description]</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AssertionError</span>
<span class="sd">        if mapFunction is None.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">mapFunction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Error: mapFunction cannot be None.&quot;</span><span class="p">;</span>

    <span class="c1"># Don&#39;t spin up more processes than necessary.</span>

    <span class="n">numProcesses</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">maxNumProcesses</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputList</span><span class="p">));</span>

    <span class="c1"># Wrap mapFunction in a FunctionMapper class, and call QueueMap with numProcesses copies of it.</span>

    <span class="n">mapper</span> <span class="o">=</span> <span class="n">FunctionMapper</span><span class="p">(</span><span class="n">mapFunction</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">QueueMap</span><span class="p">(</span><span class="n">inputList</span><span class="p">,</span> <span class="p">[</span><span class="n">mapper</span><span class="p">]</span> <span class="o">*</span> <span class="n">numProcesses</span><span class="p">,</span> <span class="n">progressBar</span> <span class="o">=</span> <span class="n">progressBar</span><span class="p">);</span></div>

<div class="viewcode-block" id="_QueueMap_ProcessMain"><a class="viewcode-back" href="../../../Transformer.Utilities.MultiprocessingHelper.html#Transformer.Utilities.MultiprocessingHelper._QueueMap_ProcessMain">[docs]</a><span class="k">def</span> <span class="nf">_QueueMap_ProcessMain</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">inputQueue</span><span class="p">,</span> <span class="n">outputQueue</span><span class="p">,</span> <span class="n">terminateFlag</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Worker process function for processes spawned by the :func:`~MultiprocessingHelperQueueMap` function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mapper : [type]</span>
<span class="sd">        Mapper object to be used to map input items to outputs.</span>
<span class="sd">    inputQueue : [type]</span>
<span class="sd">        queue from which to retrieve (index, item) tuples to process.</span>
<span class="sd">    outputQueue : [type]</span>
<span class="sd">        queue in which to place (index, item) output.</span>
<span class="sd">    terminateFlag : [type]</span>
<span class="sd">        shared-memory flag used to signal the worker process to terminate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Try to get an input item from the input queue and process it.</span>

            <span class="n">index</span><span class="p">,</span> <span class="n">inputItem</span> <span class="o">=</span> <span class="n">inputQueue</span><span class="o">.</span><span class="n">get_nowait</span><span class="p">();</span>

            <span class="n">outputItem</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">Map</span><span class="p">(</span><span class="n">inputItem</span><span class="p">);</span>

            <span class="c1"># In this case, we do want to wait until we can put outputItem back into the queue.</span>

            <span class="n">outputQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span>
                <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">outputItem</span><span class="p">)</span>
                <span class="p">);</span>

        <span class="k">except</span> <span class="n">Empty</span><span class="p">:</span>
            <span class="c1"># Check whether the process has been signalled to terminate.</span>
            <span class="c1"># If not, sleep for a delay and check the input queue again.</span>

            <span class="k">if</span> <span class="n">terminateFlag</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span><span class="p">;</span>

            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">PollDelay</span><span class="p">);</span></div>


<span class="c1"># -----------------------</span>
<span class="c1"># QueueAccumulate Routine</span>
<span class="c1"># -----------------------</span>

<div class="viewcode-block" id="QueueAccumulate"><a class="viewcode-back" href="../../../Transformer.Utilities.MultiprocessingHelper.html#Transformer.Utilities.MultiprocessingHelper.QueueAccumulate">[docs]</a><span class="k">def</span> <span class="nf">QueueAccumulate</span><span class="p">(</span><span class="n">inputList</span><span class="p">,</span> <span class="n">accumulators</span><span class="p">,</span> <span class="n">progressBar</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Accumulate items in inputList, dividing the work among the supplied set of Accumulator objects.</span>
<span class="sd">    Each Accumulator is passed to a worker process, and the input list is processed in parallel using a queue-based system.</span>

<span class="sd">    .. note::</span>
<span class="sd">        - If only one Accumulator is supplied, the input list will be processed in serial.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        - As for the :func:`~MultiprocessingHelper.QueueMap` function, setting `progressBar = True` when the :mod:`tqdm` module is not available will issue a warning, and a progress bar will not be displayed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inputList : list</span>
<span class="sd">        list of inputs to process with Accumulators.</span>
<span class="sd">    accumulators : [type]</span>
<span class="sd">        a set of user-defined Accumulator objects; the number supplied sets the number of worker processes spawned.</span>
<span class="sd">    progressBar : bool, optional</span>
<span class="sd">        if True, display a progress bar during mapping (requires the `tqdm` module).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    accumulatorResults : list</span>
<span class="sd">        [description]</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AssertionError</span>
<span class="sd">        if inputList is None.</span>
<span class="sd">    Exception</span>
<span class="sd">        if no accumulator is supplied.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    

    <span class="k">assert</span> <span class="n">inputList</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Error: inputList cannot be None.&quot;</span><span class="p">;</span>

    <span class="k">assert</span> <span class="nb">any</span><span class="p">((</span><span class="n">accumulators</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">accumulators</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)),</span> <span class="s2">&quot;Error: inputList cannot be None.&quot;</span><span class="p">;</span>

    <span class="c1"># If progressBar is set but the tqdm module is not available, issue a warning and reset it.</span>

    <span class="k">if</span> <span class="n">progressBar</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_TQDM</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The tqdm module could not be imported -&gt; progressBar will be reset to False.&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">);</span>

        <span class="n">progressBar</span> <span class="o">=</span> <span class="kc">False</span><span class="p">;</span>

    <span class="n">numInputItems</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputList</span><span class="p">);</span>

    <span class="c1"># Set up a primary iterator.</span>
    <span class="c1"># If the tqdm module is available, wrap the iterator to display a progress bar.</span>

    <span class="n">iValues</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">numInputItems</span><span class="p">);</span>

    <span class="k">if</span> <span class="n">progressBar</span><span class="p">:</span>
        <span class="n">iValues</span> <span class="o">=</span> <span class="n">tqdm</span><span class="o">.</span><span class="n">tqdm</span><span class="p">(</span><span class="n">iValues</span><span class="p">);</span>

    <span class="c1"># Variable to store accumulator results.</span>

    <span class="n">accumulatorResults</span> <span class="o">=</span> <span class="kc">None</span><span class="p">;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">accumulators</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># If there&#39;s only one accumulator, there&#39;s no point in passing all the inputs and outputs through shared-memory queues.</span>

        <span class="n">accumulator</span> <span class="o">=</span> <span class="n">accumulators</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iValues</span><span class="p">:</span>
            <span class="n">accumulator</span><span class="o">.</span><span class="n">Accumulate</span><span class="p">(</span><span class="n">inputList</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

        <span class="n">accumulatorResults</span> <span class="o">=</span> <span class="p">[</span><span class="n">accumulator</span><span class="o">.</span><span class="n">Finalise</span><span class="p">()];</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Queue for passing input items to worker processes and receving finalised results.</span>

        <span class="n">inputQueue</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Queue</span><span class="p">();</span>
        <span class="n">outputQueue</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Queue</span><span class="p">();</span>

        <span class="c1"># Shared-memory counter to keep track of the number if input items processed.</span>

        <span class="n">inputCounter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">();</span>

        <span class="c1"># Flag to signal worker processes to finalise and return the results of the accumulations and terminate.</span>

        <span class="n">terminateFlag</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="c1"># Initialise workers.</span>

        <span class="n">workerProcesses</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span> <span class="o">=</span> <span class="n">_QueueAccumulate_ProcessMain</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">accumulator</span><span class="p">,</span> <span class="n">inputQueue</span><span class="p">,</span> <span class="n">inputCounter</span><span class="p">,</span> <span class="n">outputQueue</span><span class="p">,</span> <span class="n">terminateFlag</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">accumulator</span> <span class="ow">in</span> <span class="n">accumulators</span>
            <span class="p">];</span>

        <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">workerProcesses</span><span class="p">:</span>
            <span class="n">process</span><span class="o">.</span><span class="n">start</span><span class="p">();</span>

        <span class="c1"># Send input items to the worker threads and monitor the progress through the shared counter.</span>
        <span class="c1"># Once all the input items have been accumulated, set the terminate flag and receive and return the results of the accumualations.</span>

        <span class="c1"># As in the QueueMap() routine, a general implementation requires input items to be queued in batches.</span>

        <span class="n">batchSize</span> <span class="o">=</span> <span class="n">QueueBatchItemsPerProcess</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">workerProcesses</span><span class="p">);</span>

        <span class="n">inputListPointer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1"># Initial batch of work items.</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">batchSize</span><span class="p">,</span> <span class="n">numInputItems</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">inputQueue</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">(</span><span class="n">inputList</span><span class="p">[</span><span class="n">inputListPointer</span><span class="p">]);</span>
                <span class="n">inputListPointer</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">except</span> <span class="n">Full</span><span class="p">:</span>
                <span class="k">break</span><span class="p">;</span>

        <span class="c1"># Queue remaining items and monitor progress with the shared counter.</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iValues</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="n">batchSize</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="n">inputListPointer</span><span class="p">:</span>
                <span class="c1"># Queue more input items if available.</span>

                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">batchSize</span><span class="p">,</span> <span class="n">numInputItems</span> <span class="o">-</span> <span class="n">inputListPointer</span><span class="p">)):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">inputQueue</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">(</span><span class="n">inputList</span><span class="p">[</span><span class="n">inputListPointer</span><span class="p">]);</span>
                        <span class="n">inputListPointer</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="k">except</span> <span class="n">Full</span><span class="p">:</span>
                        <span class="k">break</span><span class="p">;</span>

            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="c1"># Poll until the shared counter is &gt;= i.</span>

                <span class="k">if</span> <span class="n">inputCounter</span><span class="o">.</span><span class="n">Current</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">i</span><span class="p">:</span>
                    <span class="k">break</span><span class="p">;</span>

                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">PollDelay</span><span class="p">);</span>

        <span class="c1"># Set the terminate flag and receive results from the worker processes.</span>

        <span class="n">terminateFlag</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="c1"># get() should block until items are available, and we know how many we expect to receive -&gt; no need to poll.</span>

        <span class="n">accumulatorResults</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">outputQueue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">accumulators</span>
            <span class="p">];</span>

        <span class="c1"># Wait for processes to terminate.</span>

        <span class="k">for</span> <span class="n">process</span> <span class="ow">in</span> <span class="n">workerProcesses</span><span class="p">:</span>
            <span class="n">process</span><span class="o">.</span><span class="n">join</span><span class="p">();</span>

    <span class="c1"># Padding after progress bar.</span>

    <span class="k">if</span> <span class="n">progressBar</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">();</span>

    <span class="c1"># Return results.</span>

    <span class="k">return</span> <span class="n">accumulatorResults</span><span class="p">;</span></div>

<div class="viewcode-block" id="_QueueAccumulate_ProcessMain"><a class="viewcode-back" href="../../../Transformer.Utilities.MultiprocessingHelper.html#Transformer.Utilities.MultiprocessingHelper._QueueAccumulate_ProcessMain">[docs]</a><span class="k">def</span> <span class="nf">_QueueAccumulate_ProcessMain</span><span class="p">(</span><span class="n">accumulator</span><span class="p">,</span> <span class="n">inputQueue</span><span class="p">,</span> <span class="n">inputCounter</span><span class="p">,</span> <span class="n">outputQueue</span><span class="p">,</span> <span class="n">terminateFlag</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Worker process function for processes spawned by the :func:`~MultiprocessingHelper.QueueAccumulate` function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    accumulator : [type]</span>
<span class="sd">        Accumulator object to be used to accumulate input items.</span>
<span class="sd">    inputQueue : [type]</span>
<span class="sd">        queue from which to retrieve input items to process.</span>
<span class="sd">    inputCounter : [type]</span>
<span class="sd">        shared-memory counter used to track the progress of the input processing.</span>
<span class="sd">    outputQueue : [type]</span>
<span class="sd">        queue in which to place the result returned by the `Finalise()` method of the accumulator once all input items have been processed.</span>
<span class="sd">    terminateFlag : [type]</span>
<span class="sd">        shared-memory flag used to signal the worker process to finalise the accumulation, return the result, and terminate.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Try to get an item from the input queue.</span>
            <span class="c1"># If successful, accumulate it and increment the shared counter.</span>

            <span class="n">inputItem</span> <span class="o">=</span> <span class="n">inputQueue</span><span class="o">.</span><span class="n">get_nowait</span><span class="p">();</span>

            <span class="n">accumulator</span><span class="o">.</span><span class="n">Accumulate</span><span class="p">(</span><span class="n">inputItem</span><span class="p">);</span>

            <span class="n">inputCounter</span><span class="o">.</span><span class="n">Increment</span><span class="p">();</span>

        <span class="k">except</span> <span class="n">Empty</span><span class="p">:</span>
            <span class="c1"># If terminateFlag is set, call the Finalise() method on the accumulator and put the result into the output queue.</span>
            <span class="c1"># If not, sleep for a delay and check the input queue again.</span>

            <span class="k">if</span> <span class="n">terminateFlag</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">outputQueue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span>
                    <span class="n">accumulator</span><span class="o">.</span><span class="n">Finalise</span><span class="p">()</span>
                    <span class="p">);</span>

                <span class="k">break</span><span class="p">;</span>

            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">PollDelay</span><span class="p">);</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Jonathan M Skelton.
      <span class="lastupdated">Last updated on Dec 30, 2021.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>